/* ******************************************************
EracleRMS.cpp:
 *
For each acquisition opens the the three output files
generated by FastICAand compute RMS for each of them.
At the end of run there are 3* NUM_ACQ values of RMS
stored in file RMS.txt in Eracle_RMS.
These values will be used to train the NN.
 ******************************************************* */

#include "stdafx.h"
#include "Eracle.h"
#include <iostream>
#include <string>
#include <fstream>
#include <sstream>
#include "ltiMatrix .h"
#include "s2ws.h"

using namespace std ;

#define MAX_LOADSTRING 100

// movement repetitions
#define NUM_ACQ 10

// number of sampled data
#define DIM_CHANNEL 1010

void EracleRMS (){
	MessageBox (NULL, TEXT ("Begin of RMS"),
			TEXT("EracleRMS"), MB_OK );
	int indiceRMS = 1;
	ostringstream ossRMS;
	// output filestream
	fstream RootMeanSquare;
	RootMeanSquare.open("\\Storage Card\\Eracle_RMS\\RMS.txt ",
			fstream::out);
	while (indiceRMS <= NUM_ACQ){
		/* open files created by fastICA,
		 * read the formatted value (double)
		 * and fill a matrix, one column for each channel */
		string RMSInputPrefix = "\\Storage Card\\Eracle_FastICA\\Acq ";
		ossRMS << indiceRMS;
		string RMSNumFile = ossRMS.str ();
		string RMSInput1 = "\\Clean1_ICA.txt ";
		string RMSInput2 = "\\Clean2_ICA.txt ";
		string RMSInput3 = "\\Clean3_ICA.txt ";
		string RMSInput1Path = RMSInputPrefix +
				RMSNumFile + RMSInput1 ;
		string RMSInput2Path = RMSInputPrefix +
				RMSNumFile + RMSInput2 ;
		string RMSInput3Path = RMSInputPrefix +
				RMSNumFile + RMSInput3 ;
		FILE * source1 ;
		FILE * source2 ;
		FILE * source3 ;
		source1 = fopen (RMSInput1Path.data(), "r");
		source2 = fopen (RMSInput2Path.data(), "r");
		source3 = fopen (RMSInput3Path.data(), "r");

		/* check for files opening error */
		if ((source1 == NULL)||
				(source2 == NULL)||
				(source3 == NULL)||
				(RootMeanSquare.fail())) {
			MessageBox(NULL, TEXT("Error in opening input files"),
					TEXT("EracleRMS"), MB_OK );
		}
		/* one array for each source,
		 * and a global vector that will
		 * be use to fill the matrix */
		double source1_data[DIM_CHANNEL];
		double source2_data[DIM_CHANNEL];
		double source3_data[DIM_CHANNEL];
		double source_tot[DIM_CHANNEL*3];
		// copy data from files to vectors
		for (int k = 0; k < DIM_CHANNEL; k++){
			fscanf(source1 , "%lf", &source1_data[k]);
			fscanf(source2 , "%lf", &source2_data[k]);
			fscanf(source3 , "%lf", &source3_data[k]);
		}
		/* check equal and fixed number
		 * of data acquired , exit if different */
		if((sizeof(source1_data)/sizeof(double) != DIM_CHANNEL)||
				(sizeof(source2_data)/sizeof(double) != DIM_CHANNEL)||
				(sizeof(source3_data)/sizeof(double) != DIM_CHANNEL)) {
			MessageBox (NULL, TEXT("Array size error"),
					TEXT("EracleRMS"), MB_OK);
			exit(0);
		}
		// fill the global vector
		int i;
		for (i=0; i < DIM_CHANNEL; i++){
			source_tot[i] = source1_data[i];
		}
		for (i=DIM_CHANNEL; i < DIM_CHANNEL*2; i++) {
			source_tot[i] = source2_data[i-DIM_CHANNEL];
		}
		for (i=DIM_CHANNEL*2; i < DIM_CHANNEL*3; i++){
			source_tot[i]= source3_data[i-DIM_CHANNEL*2];
		}
		/* matrix creation : 3 rows ( one per source )
		 * and DIM_CHANNEL column */
		lti::matrix <double> clean_source (3, DIM_CHANNEL, source_tot);
		/* apply the formula:
		 * sqrt((1/DIM_CHANNEL)*SUM(i=0, i=DIM_CHANNEL)[Si^2])
		 * for each column of the matrix generated by EracleFastICA function.
		 * The value of RMS are stored in a file, separated by a blank spaces */
		double RMS ;
		double sumOfSquare=0;
		for (int ch=0; ch<3; ch++){
			for (int k=0; k < DIM_CHANNEL ; k++) {
				sumOfSquare = sumOfSquare + pow (clean_source.at(ch, k), 2);
			}
			RMS = sqrt(sumOfSquare/DIM_CHANNEL);
			RootMeanSquare << RMS *100;
			RootMeanSquare <<" ";
			RMS = 0;
			sumOfSquare = 0;
		}
		fclose (source1);
		fclose (source2);
		fclose (source3);
		// flush of ostringstream
		ossRMS.str("");
		ossRMS.clear();
		indiceRMS++; // loop variable ++
	}
	RootMeanSquare.close();
	MessageBox(NULL, TEXT("End of RMS calculation"),
			TEXT("EracleRMS"), MB_OK);
	return;
}
