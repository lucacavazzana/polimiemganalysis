/* *********************************************************
EracleParser.cpp:
*
Read(one by one ) the files generated by
EracleSerialPortManager and split them into three
different files : one file for each channel.
Input files are limited to DIM_CHANNEL samples each.
Every input files is also cleaned from spurious data at
the beginning and at the end of the stream.
Input files are stored in \Storage Card\Eracle_Acquisizioni
Output files(three for each input file) are stored in
\Storage Card\ Eracle_Parser in a subfolder
named after the acquisition step of acquisition.
 ********************************************************** */

#include "stdafx.h"
#include "Eracle.h"
#include <fstream>
#include <algorithm>
#include <sstream>
#include "s2ws.h"

#define MAX_LOADSTRING 100

// resture repetitions
#define NUM_ACQ 10

// number of samples
#define DIM_CHANNEL 1010

using namespace std;

void EracleParser() {

	int indiceParser = 1;
	ostringstream ossParser;
	MessageBox(NULL, TEXT("Begin of parsing"), TEXT("EracleParser"), MB_OK);

	while (indiceParser <= NUM_ACQ){
		int posD = 0;
		fstream input_data; // input stream to get data

		// the three resulting files, one per channel
		fstream Channel_1, Channel_2, Channel_3;

		/* the string that will contain all the EMG board's output
		 * (file DATA.txt) */
		string tot = "";

		/* strings for parser input */
		string parserInputPrefix = "\\Storage Card\\Eracle_Acquisizioni\\DATI";
		string parserSuffix = ".txt";

		ossParser << indiceParser;
		// string with number of file that will be parsed
		string parserNumFile = ossParser.str();

		string parserInputPath = parserInputPrefix + parserNumFile + parserSuffix;
		std::wstring stemp = s2ws(parserInputPath);
		// parser input result is the path to the file to be open
		LPCWSTR parserInputResult = stemp.c_str();
		/* strings for parser output */
		string parserOutputPrefix = "\\Storage Card\\Eracle_Parser\\Acq";
		/* create one directory for
		 * each acquisition in folder Eracle_Parser */
		string parserOutFolder = parserOutputPrefix + parserNumFile;
		std::wstring stemp1 = s2ws(parserOutFolder);
		LPCWSTR parserFolderResult = stemp1.c_str();
		CreateDirectory(parserFolderResult, NULL);

		string parserFileOutput1 = "\\Channel_1.txt";
		string parserFileOutput2 = "\\Channel_2.txt";
		string parserFileOutput3 = "\\Channel_3.txt";
		string parserPathOutput1 = parserOutFolder + parserFileOutput1;
		string parserPathOutput2 = parserOutFolder + parserFileOutput2;
		string parserPathOutput3 = parserOutFolder + parserFileOutput3;
		std::wstring stemp_uno = s2ws(parserPathOutput1);
		std::wstring stemp_due = s2ws(parserPathOutput2);
		std::wstring stemp_tre = s2ws(parserPathOutput3);
		LPCWSTR parserOutPath1Result = stemp_uno.c_str();
		LPCWSTR parserOutPath2Result = stemp_due.c_str();
		LPCWSTR parserOutPath3Result = stemp_tre.c_str();

		// open stream to read data file
		input_data.open(parserInputResult, fstream::in);
		// open stream to the three output files
		Channel_1.open(parserOutPath1Result, fstream::out);
		Channel_2.open(parserOutPath2Result, fstream::out);
		Channel_3.open(parserOutPath3Result, fstream::out);
		/* check for file opening error */
		if ((input_data.fail()) || (Channel_1.fail()) || 
			(Channel_2.fail()) || (input_data.fail()) || (Channel_3.fail())) {
			MessageBox (NULL, TEXT("Error in opening files"), TEXT("EracleParser"), MB_OK);
			exit(0);
		}

		/* read all the data in input stream and
		 * store them in string tot */
		while(input_data.good()){
			getline(input_data, tot);
		}
		/* ****************************************
		 * BEGIN OF PARSING ***********************
		 * **************************************** */
		/* (((1))) replace newline and carriage return with spaces */
		replace(tot.begin(), tot.end(), '\r', ' ');
		replace(tot.begin(), tot.end(), '\n', ' ');

		/* (((2))) find and erase spurious
		 * input vector at the begin of data */
		posD = tot.find("D"); // find the position of the first D
		if(posD != 0){ // if file doesn ’t begin with D...
			tot.erase(0, posD); // ... erase alla charachters before D
		}

		/* (((3))) delete the last input vector,
		 * to prevent spurious data at the end of stream */
		size_t ultimo;
		size_t fine;
		// get the position of last D...
		ultimo = tot.rfind("D");
		// ... and the position of the termination char
		fine = tot.rfind("\0");
		// delete last row, but don ’t erase "\0" charachter
		tot.erase(ultimo, fine -1);

		/* (((4))) count the number of D
		 * --> this is also the number of rows
		 * --> this is also the number of " good " data acquired */
		// numbers of " clean " data acquired
		int conteggio = count(tot.begin(), tot.end(), 'D');
		if(conteggio < DIM_CHANNEL){
			MessageBox(NULL, TEXT("Pochi campioni"), TEXT("EracleParser"), MB_OK);
			exit(0);
		}

		/* (((5))) split string tot in three files,
		 * each column to a file, each data separated
		 * by a blank spaces(included the last one )*/
		size_t begin, end;
		// get the indexes of the first number in first row
		begin = tot.find("D");
		end = tot.find(" ");
		int index;
		int row_count = 0;
		// run until 1010 lines have been parsed
		while(row_count < DIM_CHANNEL ){
			/* for the first number indexes
			 * have already been acquired */
			if(row_count >0){
				begin = tot.find("D", end);
				end = tot.find(" ", begin+1);
			}
			// first number of the triple --> to file Channel_1
			for(index = static_cast <int>(begin)+2;
					index < static_cast <int>(end); index++){
				Channel_1 << tot [index];
			}
			Channel_1 << " ";
			// adjust indexes
			begin = tot.find(" ", end);
			end = tot.find(" ", begin+1);

			// second number of the triple --> to file Channel_2
			for(index = static_cast <int>(begin)+1;
					index < static_cast <int>(end); index++){
				Channel_2 << tot[index];
			}
			Channel_2 << " ";
			// adjust indexes
			begin = tot.find(" ", end);
			end = tot.find(" ", begin+1);

			// last number of the triple --> to file Channel_3
			for(index = static_cast <int>(begin)+1;
					index < static_cast <int>(end); index++){
				Channel_3 << tot[index];
			}
			Channel_3 << " ";
			row_count++;
		}

		/* close all streams */
		Channel_1.close();
		Channel_2.close();
		Channel_3.close();
		input_data.close();

		// parsingCheck(conteggio);
		// clear the itoa buffer
		ossParser.str ("");
		ossParser.clear();
		indiceParser++; // loop variable++
	}
	MessageBox (NULL, TEXT("End of Parsing"), TEXT ("eracleParser"), MB_OK);
	return;
}